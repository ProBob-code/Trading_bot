"""
Base Strategy
==============

Abstract base class for all trading strategies.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Tuple
import pandas as pd
import numpy as np
from loguru import logger


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        signal_type: Type of signal (buy/sell/hold)
        symbol: Trading symbol
        price: Current price when signal was generated
        confidence: Signal confidence (0-1)
        timestamp: When signal was generated
        reason: Human-readable explanation
        metadata: Additional signal data
    """
    signal_type: SignalType
    symbol: str
    price: float
    confidence: float = 1.0
    timestamp: datetime = None
    reason: str = ""
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    metadata: Dict = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.metadata is None:
            self.metadata = {}
    
    def to_dict(self) -> Dict:
        """Convert signal to dictionary."""
        return {
            'signal_type': self.signal_type.value,
            'symbol': self.symbol,
            'price': self.price,
            'confidence': self.confidence,
            'timestamp': self.timestamp.isoformat(),
            'reason': self.reason,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'position_size': self.position_size,
            'metadata': self.metadata
        }


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.
    
    All strategies must implement:
    - generate_signals(): Analyze data and generate trading signals
    - calculate_indicators(): Add required indicators to data
    
    Strategies may optionally implement:
    - validate_signal(): Additional signal validation
    - get_position_size(): Custom position sizing
    """
    
    def __init__(self, name: str = "BaseStrategy", params: Dict = None):
        """
        Initialize strategy.
        
        Args:
            name: Strategy name
            params: Strategy parameters
        """
        self.name = name
        self.params = params or {}
        self.signals_history: List[Signal] = []
        self.is_initialized = False
        
    @abstractmethod
    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Add required indicators to the dataframe.
        
        Args:
            df: OHLCV DataFrame
            
        Returns:
            DataFrame with indicators added
        """
        pass
    
    @abstractmethod
    def generate_signals(
        self,
        df: pd.DataFrame,
        symbol: str = "UNKNOWN"
    ) -> List[Signal]:
        """
        Generate trading signals from data.
        
        Args:
            df: DataFrame with OHLCV and indicators
            symbol: Trading symbol
            
        Returns:
            List of signals (typically one for the latest bar)
        """
        pass
    
    def get_latest_signal(
        self,
        df: pd.DataFrame,
        symbol: str = "UNKNOWN"
    ) -> Optional[Signal]:
        """
        Get the most recent signal.
        
        Convenience method that returns only the latest signal.
        """
        signals = self.generate_signals(df, symbol)
        return signals[-1] if signals else None
    
    def validate_signal(self, signal: Signal, df: pd.DataFrame) -> bool:
        """
        Validate a signal before execution.
        
        Override this method to add custom validation logic.
        
        Args:
            signal: Signal to validate
            df: Current market data
            
        Returns:
            True if signal is valid
        """
        # Default validation
        if signal.confidence < 0.5:
            return False
        return True
    
    def calculate_stop_loss(
        self,
        df: pd.DataFrame,
        signal: Signal,
        method: str = "atr",
        **kwargs
    ) -> float:
        """
        Calculate stop loss price.
        
        Args:
            df: DataFrame with indicators
            signal: Trading signal
            method: 'fixed', 'atr', 'support'
            
        Returns:
            Stop loss price
        """
        current_price = df['close'].iloc[-1]
        
        if method == "fixed":
            pct = kwargs.get('pct', 0.02)
            if signal.signal_type == SignalType.BUY:
                return current_price * (1 - pct)
            else:
                return current_price * (1 + pct)
                
        elif method == "atr":
            multiplier = kwargs.get('multiplier', 2.0)
            atr = df['atr'].iloc[-1] if 'atr' in df.columns else current_price * 0.02
            if signal.signal_type == SignalType.BUY:
                return current_price - (atr * multiplier)
            else:
                return current_price + (atr * multiplier)
                
        return current_price * (0.98 if signal.signal_type == SignalType.BUY else 1.02)
    
    def calculate_take_profit(
        self,
        df: pd.DataFrame,
        signal: Signal,
        stop_loss: float,
        risk_reward: float = 2.0
    ) -> float:
        """
        Calculate take profit price.
        
        Args:
            df: DataFrame with indicators
            signal: Trading signal
            stop_loss: Stop loss price
            risk_reward: Risk/reward ratio
            
        Returns:
            Take profit price
        """
        current_price = df['close'].iloc[-1]
        risk = abs(current_price - stop_loss)
        
        if signal.signal_type == SignalType.BUY:
            return current_price + (risk * risk_reward)
        else:
            return current_price - (risk * risk_reward)
    
    def backtest(
        self,
        df: pd.DataFrame,
        initial_capital: float = 100000,
        position_size_pct: float = 0.1,
        symbol: str = "UNKNOWN"
    ) -> pd.DataFrame:
        """
        Simple backtest of the strategy.
        
        Args:
            df: Historical OHLCV data with indicators
            initial_capital: Starting capital
            position_size_pct: Position size as fraction of capital
            symbol: Symbol for signals
            
        Returns:
            DataFrame with backtest results
        """
        df = df.copy()
        
        # Generate signals for all rows
        signals = []
        for i in range(len(df)):
            if i < 50:  # Need enough history
                signals.append(SignalType.HOLD)
                continue
            
            partial_df = df.iloc[:i+1]
            signal = self.get_latest_signal(partial_df, symbol)
            
            if signal:
                signals.append(signal.signal_type)
            else:
                signals.append(SignalType.HOLD)
        
        df['signal'] = signals
        
        # Simulate trades
        capital = initial_capital
        position = 0
        entry_price = 0
        trades = []
        
        for i in range(1, len(df)):
            signal = df['signal'].iloc[i]
            price = df['close'].iloc[i]
            
            if signal == SignalType.BUY and position == 0:
                # Open long
                position_value = capital * position_size_pct
                position = position_value / price
                entry_price = price
                capital -= position_value
                
            elif signal == SignalType.SELL and position > 0:
                # Close long
                exit_value = position * price
                pnl = exit_value - (position * entry_price)
                trades.append({
                    'entry_date': df.index[i-1],
                    'exit_date': df.index[i],
                    'entry_price': entry_price,
                    'exit_price': price,
                    'pnl': pnl,
                    'pnl_pct': (pnl / (position * entry_price)) * 100
                })
                capital += exit_value
                position = 0
        
        # Close any open position
        if position > 0:
            exit_value = position * df['close'].iloc[-1]
            capital += exit_value
        
        # Calculate metrics
        trades_df = pd.DataFrame(trades) if trades else pd.DataFrame()
        
        final_capital = capital
        total_return = (final_capital - initial_capital) / initial_capital * 100
        
        logger.info(f"Backtest complete: {len(trades)} trades, {total_return:.2f}% return")
        
        return trades_df
    
    def get_required_indicators(self) -> List[str]:
        """Return list of required indicator names."""
        return []
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name='{self.name}')"
